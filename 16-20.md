16.输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则

### 代码的鲁棒性

方法一：非递归

```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
       if(list1 == null)
           return list2;
        if(list2 == null)
           return list1;
        ListNode new_list = null;
        if(list1.val <= list2.val){
             new_list = list1;  //合并链表的头结点
            list1 = list1.next;
        }  
        else{
            new_list = list2;
            list2 = list2.next;
        }
        ListNode cur = new_list;
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                cur.next = list1;
                list1 = list1.next;
                cur = cur.next;
            }else{
                cur.next = list2;
                list2 = list2.next;
                cur = cur.next;
            }
        }
        if(list1 ==null)
            cur.next = list2;
        else
            cur.next = list1;

        return new_list;
    }
}
```

方法二：递归，如下图

![](/assets/递归.png)

```java
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null)
            return list2;
        if(list2 == null)
            return list1;
        ListNode h = null;
        // 递归
        if(list1.val <= list2.val){
            h = list1;
            h.next = Merge(list1.next,list2);
        }else{
            h = list2;
            h.next = Merge(list1,list2.next);
        }
        return h;
    }
}
```



